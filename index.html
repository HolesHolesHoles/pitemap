<script>
  const EMAIL_ENDPOINT = "/.netlify/functions/location-email";

  // --- PieSocket (safe init) ---
  let piesocket = null;
  try {
    piesocket = new PieSocket({
      clusterId: "free.blr2",
      apiKey: "B9UKgvptNTWrZxfCUTquFp7nKVsYqu2LtmBao5Jg",
      notifySelf: true,
      presence: true,
    });
  } catch (e) {
    console.warn("PieSocket failed to init, continuing without realtime:", e);
    piesocket = null;
  }

  // --- State ---
  let channel = null;
  let map = null;
  let userMarker = null;
  let newMarker = null;
  let routingControl = null;
  let lastPos = null;
  let watchId = null;

  // --- UI ---
  const btnStart = document.getElementById("btnStart");
  const btnEmail = document.getElementById("btnEmail");
  const statusEl = document.getElementById("status");

  function setStatus(msg) {
    statusEl.textContent = msg;
  }

  function initMap(lat, lng) {
    map = L.map("map").setView([lat, lng], 12);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: "© OpenStreetMap contributors",
    }).addTo(map);

    userMarker = L.marker([lat, lng]).addTo(map);

    // Click to set destination + draw route
    map.on("click", (e) => {
      if (!userMarker) return;

      const dest = [e.latlng.lat, e.latlng.lng];

      if (newMarker) newMarker.setLatLng(dest);
      else newMarker = L.marker(dest).addTo(map);

      if (routingControl) map.removeControl(routingControl);

      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(userMarker.getLatLng().lat, userMarker.getLatLng().lng),
          L.latLng(newMarker.getLatLng().lat, newMarker.getLatLng().lng),
        ],
        addWaypoints: false,
        draggableWaypoints: false,
      }).addTo(map);

      // broadcast route (optional)
      if (channel) {
        channel.publish(
          "route",
          JSON.stringify({
            user: userMarker.getLatLng(),
            dest: newMarker.getLatLng(),
          })
        );
      }
    });
  }

  async function subscribePieSocket() {
    if (!piesocket) {
      setStatus("Realtime disabled (PieSocket not available). Map still works.");
      return;
    }
    if (channel) return; // already subscribed

    channel = await piesocket.subscribe("chat-room");

    // Live user marker updates
    channel.listen("updateUserMarker", (data) => {
      if (!map) return;
      const loc = JSON.parse(data);

      if (userMarker) userMarker.setLatLng([loc.latitude, loc.longitude]);
      else userMarker = L.marker([loc.latitude, loc.longitude]).addTo(map);
    });

    // Live route updates
    channel.listen("route", (data) => {
      if (!map) return;
      const msg = JSON.parse(data);

      if (!userMarker) userMarker = L.marker([msg.user.lat, msg.user.lng]).addTo(map);
      else userMarker.setLatLng([msg.user.lat, msg.user.lng]);

      if (!newMarker) newMarker = L.marker([msg.dest.lat, msg.dest.lng]).addTo(map);
      else newMarker.setLatLng([msg.dest.lat, msg.dest.lng]);

      if (routingControl) map.removeControl(routingControl);

      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(msg.user.lat, msg.user.lng),
          L.latLng(msg.dest.lat, msg.dest.lng),
        ],
        addWaypoints: false,
        draggableWaypoints: false,
      }).addTo(map);
    });
  }

  function startWatchingLocation() {
    if (watchId !== null) return; // already watching

    watchId = navigator.geolocation.watchPosition(
      (pos) => {
        lastPos = pos;

        const latitude = pos.coords.latitude;
        const longitude = pos.coords.longitude;

        if (userMarker) userMarker.setLatLng([latitude, longitude]);

        if (channel) {
          channel.publish("updateUserMarker", JSON.stringify({ latitude, longitude }));
        }
      },
      (err) => setStatus("Location error: " + err.message),
      { enableHighAccuracy: false, timeout: 20000, maximumAge: 600000 }
    );
  }

  async function emailMyLocation() {
    if (!lastPos) {
      setStatus("No location yet. Click Request location first.");
      return;
    }

    setStatus("Sending email…");

    const payload = {
      lat: lastPos.coords.latitude,
      lon: lastPos.coords.longitude,
      accuracy_m: lastPos.coords.accuracy,
      timestamp: new Date(lastPos.timestamp).toISOString(),
      userAgent: navigator.userAgent,
    };

    try {
      const r = await fetch(EMAIL_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (r.ok) setStatus("✅ Email sent!");
      else setStatus("❌ Email failed. Server returned " + r.status);
    } catch (e) {
      setStatus("❌ Network error: " + e.message);
    }
  }

  // ✅ Event listeners (this is what you were missing/broken)
  btnStart.addEventListener("click", async () => {
    if (!navigator.geolocation) {
      setStatus("Geolocation not supported.");
      return;
    }

    setStatus("Requesting location permission…");

    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        lastPos = pos;

        if (!map) initMap(pos.coords.latitude, pos.coords.longitude);

        await subscribePieSocket();
        startWatchingLocation();

        btnEmail.disabled = false;
        setStatus("✅ Location ready. You can email it now.");
      },
      (err) => setStatus("❌ Location error: " + err.message),
      { enableHighAccuracy: false, timeout: 20000, maximumAge: 600000 }
    );
  });

  btnEmail.addEventListener("click", emailMyLocation);
</script>

